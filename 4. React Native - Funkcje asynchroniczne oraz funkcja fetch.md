##  <img width=32 align='top' src='https://www.svgrepo.com/show/521705/hourglass.svg' /> Zapytania asynchroniczne

Asynchronizm, bo to rozumiemy pod pojÄ™ciem "funkcji" czy "zapytania" asynchronicznego polega na wykonaniu danej czynnoÅ›ci, ktÃ³ra wykona siÄ™ po jakimÅ› upÅ‚ywie czasu.

PrzykÅ‚adem moÅ¼e byÄ‡ wywoÅ‚anie zapytania `SELECT * FROM table LIMIT 1000000` gdzie dane z tabeli zostanÄ… zwrÃ³cone w iloÅ›ci miliona, zwrot tak duÅ¼ej iloÅ›ci danych potrzebuje czasu, 
nawet jeÅ¼eli bÄ™dzie to jedna sekunda wykonania.

Czyli funkcja asynchroniczna, czy zapytanie asynchroniczne jest wykonaniem zadania ktÃ³re zwrÃ³ci nam wynik ale po jakimÅ› czasie, __*bez blokowania gÅ‚ownego wÄ…tku kodu*__.

---

### Funkcje asynchroniczne 

NajczÄ™stszym wykorzystaniem mechanizmu asynchronicznego jest funkcja.
```javascript
const foo = async () =>{
  return "bar"
}

const greet = async () => {
  const message = await foo();
  console.log(message);
};

greet();
```
>[!NOTE]
> - KaÅ¼da funkcja `asynchroniczna` wykorzystuje sÅ‚owo kluczowe, okreÅ›lajÄ…ce, Å¼e jest tÄ… funkcjÄ… asynchronicznÄ… tj. `async`.
>
> - Natomiast jeÅ¼eli funkcja wywoÅ‚uje innÄ… funkcjÄ™ asynchronicznÄ…, to sama w sobie rÃ³wnieÅ¼ musi byÄ‡ asynchroniczna.
> - Wtedy asynchroniczna funkcja oczekuje na wykonanie asynchronicznej funkcji wewnÄ…trz niej samej ( tak jak w przypadku funkcji `greet` ), oznamienie oczekiwania okreÅ›lanie jest wyrazem `await` przed wywoÅ‚aniem funkcji.

JeÅ¼eli wykonaliÅ›cie funkcjÄ™ z powyÅ¼szego przykÅ‚adu to w konsoli powinniÅ›cie dostaÄ‡ informacje `Promise { <state>: "fulfilled", <value>: undefined }`.
Oznacza to, Å¼e zÅ‚oÅ¼yliÅ›cie "obietnicÄ™" (z ang. `Promise`) wykonania funkcji asynchronicznej i jej status zostaÅ‚ wykonany (`fulfilled`). 

Tutaj przechodzimy do kolejnego etapu funkcji asynchronicznych w `JavaScript`
### Obietnica Promise
Obietnice w JavaScript to mechanizm, ktÃ³ry pozwala na obsÅ‚ugÄ™ operacji asynchronicznych w bardziej czytelny i uporzÄ…dkowany sposÃ³b. 
Obietnica reprezentuje wartoÅ›Ä‡, ktÃ³ra moÅ¼e byÄ‡ dostÄ™pna teraz, w przyszÅ‚oÅ›ci lub nigdy.

IstniejÄ… 3 stany obietnic:
>[!NOTE]
> - `Pending`: PoczÄ…tkowy stan obietnicy, ktÃ³ra jeszcze nie zostaÅ‚a speÅ‚niona ani odrzucona.
>
> - `Fulfilled`: Stan, gdy obietnica zostaÅ‚a speÅ‚niona i zwrÃ³ciÅ‚a wartoÅ›Ä‡.
> - `Rejected`: Stan, gdy obietnica zostaÅ‚a odrzucona z powodu bÅ‚Ä™du.


### Tworzenie obietnic
ObietnicÄ™ tworzy siÄ™ za pomocÄ… konstruktora Promise, ktÃ³ry przyjmuje funkcjÄ™ z dwoma argumentami: resolve i reject.
Funkcja ta wykonuje operacjÄ™ asynchronicznÄ… i wywoÅ‚uje `resolve - gdy operacja zakoÅ„czy siÄ™ sukcesem`, lub `reject - gdy wystÄ…pi bÅ‚Ä…d`.
```javascript
const myPromise = new Promise((resolve, reject) => {
  // Operacja asynchroniczna
  setTimeout(() => {
    const success = true; // Zmienna symulujÄ…ca sukces operacji
    if (success) {
      resolve("Operacja zakoÅ„czona sukcesem!");
    } else {
      reject("WystÄ…piÅ‚ bÅ‚Ä…d.");
    }
  }, 2000);
});
```

#### ObsÅ‚uga obietnic
Skoro juÅ¼ obietnica zostaÅ‚a stworzona i "obiecujemy jÄ… dopilnowaÄ‡" to przydaÅ‚o by siÄ™ obsÅ‚uÅ¼yÄ‡ wynik tej obietnicy.
>[!NOTE]
> - `.then`: Metoda uÅ¼ywana do obsÅ‚ugi wyniku speÅ‚nionej obietnicy. Przyjmuje funkcjÄ™, ktÃ³ra zostanie wykonana, gdy obietnica zostanie speÅ‚niona.
>   
> - `.catch`: Metoda uÅ¼ywana do obsÅ‚ugi bÅ‚Ä™dÃ³w. Przyjmuje funkcjÄ™, ktÃ³ra zostanie wykonana, gdy obietnica zostanie odrzucona.
> - `.finally`: Metoda, ktÃ³ra zostanie wykonana niezaleÅ¼nie od tego, czy obietnica zostaÅ‚a speÅ‚niona, czy odrzucona.

```javascript
myPromise
  .then((result) => {
    console.log(result); // "Operacja zakoÅ„czona sukcesem!"
  })
  .catch((error) => {
    console.error(error); // "WystÄ…piÅ‚ bÅ‚Ä…d."
  })
  .finally(() => {
    console.log("Operacja zakoÅ„czona."); // Zawsze siÄ™ wykona
  });
```

### Funkcje asynchroniczne i obietnice

WrÃ³Ä‡my na chwilÄ™ to przykÅ‚adu poczÄ…tkowego tej strony i sprawmy, aby funkcja asynchroniczna, faktycznie odczekaÅ‚a chwilÄ™ zanim siÄ™ wykona.
```javascript
const foo = async () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("bar");
    }, 2000); // OpÃ³Åºnienie 2 sekundy
  });
};

const greet = async () => {
  const message = await foo();
  console.log(message);
};

greet();
```

WykorzystaliÅ›my do tego poznany juÅ¼ obiekt `Promise`, w ktÃ³rym to zastosowaliÅ›my funkcjÄ™ odliczajÄ…cÄ… czas, czyli sztucznÄ… przerwe czasowÄ… do wykonania jakiegoÅ› zwrotu.
Teraz w konsoli zobaczyliÅ›my `Promise { <state>: "pending" }`, czyli w momencie wykonania byÅ‚ stan "oczekujÄ…cy", a po 2 sekundach funkcja zwrÃ³ciÅ‚a nam `bar` obiecany przy sukcesie.

W momencie gdy bÄ™dziemy tworzyÄ‡ prawdziwÄ… funkcjonalnoÅ›Ä‡ asynchronicznÄ… to obiekt `Promise` musi wystÄ…piÄ‡, aby mÃ³c obsÅ‚ugiwaÄ‡ ewentualne niepowodzenia czy sukcesy naszej funkcji.

### AsynchronicznoÅ›Ä‡ w React Native
W koÅ„cu dotarliÅ›my do gÅ‚Ã³wnego tekstu tych zajÄ™Ä‡, czyli wykorzystanie asynchronicznoÅ›ci w Å¼yciu codziennym programisty `React Native`!
WiÄ™c najpopularniejszÄ… funkcjÄ… asynchronicznÄ… w jÄ™zyku `JavasScript` jest `fetch()`.

Funkcja fetch() jest funkcjÄ… wysyÅ‚ajÄ…cÄ… zapytania http na dany adres url, ktÃ³ra w podstawowej formie wysyÅ‚a zapytanie `GET`. 

```jsx
import React, { useEffect, useState } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

const App = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(json => {
        setData(json);
        setLoading(false);
      })
      .catch(error => {
        console.error(error);
        setLoading(false);
      });
  }, []);

  if (loading) {
    return <ActivityIndicator />;
  }

  return (
    <SafeAreaView style={styles.container}>
      <Text style={styles.title}>{data.title}</Text>
      <Text style={styles.item}>{data.body}</Text>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    marginTop: StatusBar.currentHeight ?? 0,
  },
  item: {
    backgroundColor: '#f9c2ff',
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 32,
  },
});


export default App;
```

W powyÅ¼szym przykÅ‚adzie mamy wykorzystanie funkcji `fetch()` w `useEffect`, ktÃ³ra to wykorzystuje deklaracjÄ™ `.then` aby po otrzymaniu zwrotu wykonaÄ‡ zamianÄ™ danych na format `JSON`.
Dopiero wtedy format `JSON` moÅ¼emy zawartoÅ›Ä‡ odpowiedzi przypisaÄ‡ do odpowiednich `useState`

```jsx
useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        const json = await response.json();
        setData(json);
      } catch (error) {
        console.error(error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
}, []);
```
Tutaj alternatywe wykonanie poprzedniego przykÅ‚adu kodu z uÅ¼yciem `try..catch..finally` bloku.

### ğŸŒ Wykonaj wÅ‚asne zapytanie do wybranego `API`
Wybierz jedno z wybranych API, a nastÄ™pnie sformatuj otrzymane dane tak aby byÅ‚y wyÅ›wietlone w przygotowanym komponencie.

- [PokeAPI](https://pokeapi.co/)
- [AdviceSlipAPI](https://api.adviceslip.com/)
- [OpenTriviaAPI](https://opentdb.com/api_config.php)
- [RandomUserAPI](https://randomuser.me/)
- [JokeAPI](https://v2.jokeapi.dev/)

### Metody `.all` oraz `.race` obiektu Promise

Obiekt promise sam w sobie posiada jeszcze dodatkowe metody do "zadaÅ„ specjalnych".
Pierwsza z tych metod to `.all` dziÄ™ki ktÃ³rej moÅ¼emy wywoÅ‚aÄ‡ kilka obietnic jednoczeÅ›nie w jednym bloku kodu.

`Promise.all` przyjmuje iterowalny obiekt (np. tablicÄ™) zawierajÄ…cy obiekty Promise i zwraca nowy Promise, ktÃ³ry rozwiÄ…zuje siÄ™, gdy wszystkie przekazane Promise zostanÄ… rozwiÄ…zane lub odrzuca siÄ™, gdy ktÃ³rykolwiek z przekazanych Promise zostanie odrzucony.

```javascript
const promise1 = new Promise((resolve) => setTimeout(() => resolve("First"), 1000));
const promise2 = new Promise((resolve) => setTimeout(() => resolve("Second"), 2000));
const promise3 = new Promise((resolve) => setTimeout(() => resolve("Third"), 3000));

Promise.all([promise1, promise2, promise3]).then((results) => {
    console.log(results); // ["First", "Second", "Third"]
}).catch((error) => {
    console.error(error);
});
```

`Promise.race` jest podobny do `.all` z tÄ… rÃ³Å¼nicÄ…, Å¼e zwrÃ³ci wykonanie tylko jednej obietnicy - tej ktÃ³ra wykona siÄ™ jako pierwsza.

```javascript
const promise1 = new Promise((resolve) => setTimeout(() => resolve("First"), 1000));
const promise2 = new Promise((resolve) => setTimeout(() => resolve("Second"), 2000));
const promise3 = new Promise((resolve) => setTimeout(() => resolve("Third"), 300));

Promise.race([promise1, promise2, promise3]).then((result) => {
    console.log(result); // "Third"
}).catch((error) => {
    console.error(error);
});
```

### ğŸŒ  Zadania powtÃ³rzeniowe
Wszystkie zadania zapisz w jÄ™zyku `React Native` wykorzystujÄ…c `useEffect`, `useState` oraz metodÄ™ `.map`.
WartoÅ›ci majÄ… pozostaÄ‡ jedynie przykÅ‚adowe, nie musi byÄ‡ to nic konkretnego.

1. Napisz funkcjÄ™ asynchronicznÄ…, ktÃ³ra zwraca wartoÅ›Ä‡ po 2 sekundach. UÅ¼yj `setTimeout` i `async/await`.
2. UtwÃ³rz obiekt Promise, ktÃ³ry rozwiÄ…zuje siÄ™ po 3 sekundach z wartoÅ›ciÄ… â€œHello, World!â€. ObsÅ‚uÅ¼ ten Promise za pomocÄ… `then`.
3. UtwÃ³rz obiekt Promise, ktÃ³ry odrzuca siÄ™ po 2 sekundach z bÅ‚Ä™dem â€œSomething went wrongâ€. ObsÅ‚uÅ¼ ten bÅ‚Ä…d za pomocÄ… `catch`.
4. UtwÃ³rz dwa obiekty Promise, ktÃ³re rozwiÄ…zujÄ… siÄ™ po rÃ³Å¼nych czasach. UÅ¼yj `Promise.all`, aby poczekaÄ‡ na oba Promise i zwrÃ³ciÄ‡ ich wyniki.
5. Napisz funkcjÄ™ asynchronicznÄ…, ktÃ³ra wykonuje trzy zadania sekwencyjnie (np. wypisanie `console.log`), kaÅ¼de z nich trwa 1 sekundÄ™. UÅ¼yj `await` do synchronizacji.
6. Napisz funkcjÄ™ asynchronicznÄ…, ktÃ³ra wykonuje trzy zadania rÃ³wnolegle, kaÅ¼de z nich trwa 1 sekundÄ™. UÅ¼yj `Promise.all` do synchronizacji.
7. UtwÃ³rz trzy obiekty Promise, ktÃ³re rozwiÄ…zujÄ… siÄ™ po rÃ³Å¼nych czasach. UÅ¼yj `Promise.race`, aby zwrÃ³ciÄ‡ wynik najszybciej rozwiÄ…zujÄ…cego siÄ™ Promise.
8. UtwÃ³rz Å‚aÅ„cuch Promise (wykorzystujac `then`), gdzie kaÅ¼dy kolejny then przetwarza wynik poprzedniego Promise. Na koÅ„cu Å‚aÅ„cucha zwrÃ³Ä‡ ostateczny wynik.
9. Napisz funkcjÄ™ asynchronicznÄ…, ktÃ³ra iteruje po tablicy wartoÅ›ci i wykonuje asynchroniczne zadanie dla kaÅ¼dej wartoÅ›ci. UÅ¼yj `for...of` i `await`.
10. Napisz funkcjÄ™ asynchronicznÄ…, ktÃ³ra wykonuje kilka zadaÅ„, z ktÃ³rych jedno moÅ¼e rzuciÄ‡ bÅ‚Ä…d. UÅ¼yj `try...catch` do obsÅ‚ugi bÅ‚Ä™dÃ³w.
