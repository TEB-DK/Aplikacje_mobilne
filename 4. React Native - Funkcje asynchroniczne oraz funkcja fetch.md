##  <img width=32 align='top' src='https://www.svgrepo.com/show/521705/hourglass.svg' /> Zapytania asynchroniczne

Asynchronizm, bo to rozumiemy pod pojciem "funkcji" czy "zapytania" asynchronicznego polega na wykonaniu danej czynnoci, kt贸ra wykona si po jakim upywie czasu.

Przykadem mo偶e by wywoanie zapytania `SELECT * FROM table LIMIT 1000000` gdzie dane z tabeli zostan zwr贸cone w iloci miliona, zwrot tak du偶ej iloci danych potrzebuje czasu, 
nawet je偶eli bdzie to jedna sekunda wykonania.

Czyli funkcja asynchroniczna, czy zapytanie asynchroniczne jest wykonaniem zadania kt贸re zwr贸ci nam wynik ale po jakim czasie, __*bez blokowania gownego wtku kodu*__.

---

### Funkcje asynchroniczne 

Najczstszym wykorzystaniem mechanizmu asynchronicznego jest funkcja.
```javascript
const foo = async () =>{
  return "bar"
}

const greet = async () => {
  const message = await foo();
  console.log(message);
};

greet();
```
>[!NOTE]
> - Ka偶da funkcja `asynchroniczna` wykorzystuje sowo kluczowe, okrelajce, 偶e jest t funkcj asynchroniczn tj. `async`.
>
> - Natomiast je偶eli funkcja wywouje inn funkcj asynchroniczn, to sama w sobie r贸wnie偶 musi by asynchroniczna.
> - Wtedy asynchroniczna funkcja oczekuje na wykonanie asynchronicznej funkcji wewntrz niej samej ( tak jak w przypadku funkcji `greet` ), oznamienie oczekiwania okrelanie jest wyrazem `await` przed wywoaniem funkcji.

Je偶eli wykonalicie funkcj z powy偶szego przykadu to w konsoli powinnicie dosta informacje `Promise { <state>: "fulfilled", <value>: undefined }`.
Oznacza to, 偶e zo偶ylicie "obietnic" (z ang. `Promise`) wykonania funkcji asynchronicznej i jej status zosta wykonany (`fulfilled`). 

Tutaj przechodzimy do kolejnego etapu funkcji asynchronicznych w `JavaScript`
### Obietnica Promise
Obietnice w JavaScript to mechanizm, kt贸ry pozwala na obsug operacji asynchronicznych w bardziej czytelny i uporzdkowany spos贸b. 
Obietnica reprezentuje warto, kt贸ra mo偶e by dostpna teraz, w przyszoci lub nigdy.

Istniej 3 stany obietnic:
>[!NOTE]
> - `Pending`: Pocztkowy stan obietnicy, kt贸ra jeszcze nie zostaa speniona ani odrzucona.
>
> - `Fulfilled`: Stan, gdy obietnica zostaa speniona i zwr贸cia warto.
> - `Rejected`: Stan, gdy obietnica zostaa odrzucona z powodu bdu.


### Tworzenie obietnic
Obietnic tworzy si za pomoc konstruktora Promise, kt贸ry przyjmuje funkcj z dwoma argumentami: resolve i reject.
Funkcja ta wykonuje operacj asynchroniczn i wywouje `resolve - gdy operacja zakoczy si sukcesem`, lub `reject - gdy wystpi bd`.
```javascript
const myPromise = new Promise((resolve, reject) => {
  // Operacja asynchroniczna
  setTimeout(() => {
    const success = true; // Zmienna symulujca sukces operacji
    if (success) {
      resolve("Operacja zakoczona sukcesem!");
    } else {
      reject("Wystpi bd.");
    }
  }, 2000);
});
```

#### Obsuga obietnic
Skoro ju偶 obietnica zostaa stworzona i "obiecujemy j dopilnowa" to przydao by si obsu偶y wynik tej obietnicy.
>[!NOTE]
> - `.then`: Metoda u偶ywana do obsugi wyniku spenionej obietnicy. Przyjmuje funkcj, kt贸ra zostanie wykonana, gdy obietnica zostanie speniona.
>   
> - `.catch`: Metoda u偶ywana do obsugi bd贸w. Przyjmuje funkcj, kt贸ra zostanie wykonana, gdy obietnica zostanie odrzucona.
> - `.finally`: Metoda, kt贸ra zostanie wykonana niezale偶nie od tego, czy obietnica zostaa speniona, czy odrzucona.

```javascript
myPromise
  .then((result) => {
    console.log(result); // "Operacja zakoczona sukcesem!"
  })
  .catch((error) => {
    console.error(error); // "Wystpi bd."
  })
  .finally(() => {
    console.log("Operacja zakoczona."); // Zawsze si wykona
  });
```

### Funkcje asynchroniczne i obietnice

Wr贸my na chwil to przykadu pocztkowego tej strony i sprawmy, aby funkcja asynchroniczna, faktycznie odczekaa chwil zanim si wykona.
```javascript
const foo = async () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("bar");
    }, 2000); // Op贸藕nienie 2 sekundy
  });
};

const greet = async () => {
  const message = await foo();
  console.log(message);
};

greet();
```

Wykorzystalimy do tego poznany ju偶 obiekt `Promise`, w kt贸rym to zastosowalimy funkcj odliczajc czas, czyli sztuczn przerwe czasow do wykonania jakiego zwrotu.
Teraz w konsoli zobaczylimy `Promise { <state>: "pending" }`, czyli w momencie wykonania by stan "oczekujcy", a po 2 sekundach funkcja zwr贸cia nam `bar` obiecany przy sukcesie.

W momencie gdy bdziemy tworzy prawdziw funkcjonalno asynchroniczn to obiekt `Promise` musi wystpi, aby m贸c obsugiwa ewentualne niepowodzenia czy sukcesy naszej funkcji.

### Asynchroniczno w React Native
W kocu dotarlimy do g贸wnego tekstu tych zaj, czyli wykorzystanie asynchronicznoci w 偶yciu codziennym programisty `React Native`!
Wic najpopularniejsz funkcj asynchroniczn w jzyku `JavasScript` jest `fetch()`.

Funkcja fetch() jest funkcj wysyajc zapytania http na dany adres url, kt贸ra w podstawowej formie wysya zapytanie `GET`. 

```jsx
import React, { useEffect, useState } from 'react';
import { View, Text, ActivityIndicator } from 'react-native';

const App = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(json => {
        setData(json);
        setLoading(false);
      })
      .catch(error => {
        console.error(error);
        setLoading(false);
      });
  }, []);

  if (loading) {
    return <ActivityIndicator />;
  }

  return (
    <SafeAreaView style={styles.container}>
      <Text style={styles.title}>{data.title}</Text>
      <Text style={styles.item}>{data.body}</Text>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    marginTop: StatusBar.currentHeight ?? 0,
  },
  item: {
    backgroundColor: '#f9c2ff',
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 32,
  },
});


export default App;
```

W powy偶szym przykadzie mamy wykorzystanie funkcji `fetch()` w `useEffect`, kt贸ra to wykorzystuje deklaracj `.then` aby po otrzymaniu zwrotu wykona zamian danych na format `JSON`.
Dopiero wtedy format `JSON` mo偶emy zawarto odpowiedzi przypisa do odpowiednich `useState`

```jsx
useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        const json = await response.json();
        setData(json);
      } catch (error) {
        console.error(error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
}, []);
```
Tutaj alternatywe wykonanie poprzedniego przykadu kodu z u偶yciem `try..catch..finally` bloku.

### Wykonaj wasne zapytanie do wybranego `API`
Wybierz jedno z wybranych API, a nastpnie sformatuj otrzymane dane tak aby byy wywietlone w przygotowanym komponencie.

- [PokeAPI](https://pokeapi.co/)
- [AdviceSlipAPI](https://api.adviceslip.com/)
- [OpenTriviaAPI](https://opentdb.com/api_config.php)
- [RandomUserAPI](https://randomuser.me/)
- [JokeAPI](https://v2.jokeapi.dev/)
