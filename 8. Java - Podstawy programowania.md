# <img src='https://www.svgrepo.com/show/452234/java.svg' height="36" align="top"> Java

Podstawy programowania w Javie zaczniemy w pliku `MainActivity.java`.
Nasz plik powinien zawieraÄ‡ gÅ‚Ã³wnÄ… klase wywoÅ‚ujÄ…cÄ… aplikacje mobilnÄ….
```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_main);
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
            return insets;
        });
    }
}
```

Klasa ta jest "rozwija" czyli dziedziczy po klasie `AppCompatActivity` pewnie wÅ‚aÅ›ciwoÅ›ci i metody, ktÃ³re mogÄ… byÄ‡ nadpisane i to wÅ‚aÅ›nie dzieje siÄ™ w przypadku metody `onCreate`.
Poprzedza jÄ… adnotacja, tak zwany `dekorator` @Override. SÅ‚uÅ¼y on by zadeklarowaÄ‡, iÅ¼ dana dziedziczona metoda bÄ™dzie nadpisana nowÄ… funkcjonalnoÅ›ciÄ…. Ale do szczegÃ³Å‚Ã³w przejdziemy pÃ³Åºniej.

Metoda ta wykonuje pewne zadania zaraz po utworzeniu widoku naszej aplikacji. GÅ‚Ã³wnie ustawia opcjÄ™ `EdgeToEdge`, nastÄ™pnie gÅ‚Ã³wny ekran zawierajÄ…cy kontent widoku oraz odpowiednie paddingi.

## Klasy

Same podstawy rozpoczniemy od zrozumienia i napisania swojej pierwszej klasy.

W drzewie plikÃ³w po lewej stronie:
- Kliknij `prawym` na pakiet utworzonej aplikacji, `app -> java -> com.example.[nazwaaplikacji]`
- Wybierz pole `New`
- Wybierz pole `Java class`
- Nadaj nazwe swojej klasie, w naszym przypadku `Counter` i wciÅ›nij `Enter`

Nasza nowa klasa powinna wyglÄ…daÄ‡ tak:

![obraz](https://github.com/user-attachments/assets/2b613189-be6d-477d-ada0-533447cc0da6)

KaÅ¼da klasa moÅ¼e zawieraÄ‡ nastÄ™pujÄ…ce elementy:
- WÅ‚aÅ›ciwoÅ›ci
- Konstruktory
- Metody
- Settery/Gettery
- GÅ‚Ã³wnÄ… metodÄ™ wywoÅ‚ujÄ…cÄ… dziaÅ‚anie klasy.

### Modyfikatory
KaÅ¼dÄ… wÅ‚aÅ›ciwoÅ›Ä‡ powinno poprzedzaÄ‡: `modyfikator` oraz `typ`.

Modyfikator widocznoÅ›ci lub zakres (z ang. `scope`) wÅ‚aÅ›ciwoÅ›ci jak i metod (poniewaÅ¼ do nich rÃ³wnieÅ¼ siÄ™ tyczÄ…) dzielÄ… siÄ™ nastÄ™pujÄ…co: 

|            | Klasa | Pakiet | Podklasa (ten sam pakiet) | Podklasa (inny pakiet) | OgÃ³Å‚ |
|------------|:-----:|:-------:|:-------------------:|:-------------------:|:-----:|
| **public** |   âœ”   |    âœ”    |         âœ”           |         âœ”           |   âœ”   |
| **protected** |   âœ”   |    âœ”    |         âœ”           |         âœ”           |   âŒ   |
| *no modifier* |   âœ”   |    âœ”    |         âœ”           |         âŒ           |   âŒ   |
| **private** |   âœ”   |    âŒ    |         âŒ           |         âŒ           |   âŒ   |

### Typy danych

Wszystko w jÄ™zyku Java musi mieÄ‡ okreÅ›lony typ, czy to bÄ™dzie wÅ‚aÅ›ciwoÅ›Ä‡ czy metoda, ktÃ³rÄ… wÅ‚aÅ›nie napisaliÅ›my.

OkreÅ›lony typ danych bÄ™dzie pilnowaÅ‚ aby metoda czy wÅ‚aÅ›ciwoÅ›Ä‡ zwrÃ³ciÅ‚a wartoÅ›Ä‡ deklarowanego typu!

| Typ danych    | Opis                                      | PrzykÅ‚adowe uÅ¼ycie w kodzie                   |
|--------------|-----------------------------------------|-----------------------------------------------|
| **Prymitywne** | **Podstawowe typy danych w Javie**     |                                               |
| `byte`       | 8-bitowa liczba caÅ‚kowita               | `byte smallNumber = 100;`                     |
| `short`      | 16-bitowa liczba caÅ‚kowita              | `short pageCount = 32000;`                    |
| `int`        | 32-bitowa liczba caÅ‚kowita              | `int age = 25;`                               |
| `long`       | 64-bitowa liczba caÅ‚kowita              | `long distance = 1000000000L;`                |
| `float`      | 32-bitowa liczba zmiennoprzecinkowa      | `float price = 10.99f;`                       |
| `double`     | 64-bitowa liczba zmiennoprzecinkowa      | `double pi = 3.14159265358979;`               |
| `char`       | Pojedynczy znak Unicode                 | `char grade = 'A';`                           |
| `boolean`    | WartoÅ›Ä‡ logiczna (`true`/`false`)       | `boolean isJavaFun = true;`                   |
| **Referencyjne** | **Obiekty i tablice**               |                                               |
| `String`     | CiÄ…g znakÃ³w                             | `String name = "John Doe";`                   |
| `Integer`    | Obiektowa wersja `int`                  | `Integer number = Integer.valueOf(42);`       |
| `Double`     | Obiektowa wersja `double`               | `Double temperature = 36.6;`                  |
| `Boolean`    | Obiektowa wersja `boolean`              | `Boolean isActive = Boolean.TRUE;`            |
| `List<T>`    | Lista dynamiczna                       | `List<String> names = new ArrayList<>();`     |
| `Set<T>`     | ZbiÃ³r unikalnych wartoÅ›ci              | `Set<Integer> uniqueNumbers = new HashSet<>();` |
| `Map<K, V>`  | Mapa klucz-wartoÅ›Ä‡                     | `Map<String, Integer> scores = new HashMap<>();` |
| `Object`     | Klasa bazowa dla wszystkich obiektÃ³w   | `Object obj = new String("Hello");`           |
| `var`        | Typ inferowany                         | `var message = "Hello, Java!";`               |

### Tworzenie klasy

Po krÃ³tkim i podstawowym wstÄ™pnie merytorycznym moÅ¼emy przejÅ›Ä‡ do utworzenia swojej pierwszej klasy, omawiajÄ…c kolejne zaganienia w trakcie.

Nasza utworzona klasa powinna nadal wyglÄ…daÄ‡ w ten sposÃ³b.
```java
public class Counter {

}
```
### Konstruktor 
Aby tÄ… klase moÅ¼na byÅ‚o `skonstruowaÄ‡` naleÅ¼y utworzyÄ‡ jej konstruktor.

>[!IMPORTANT]
>**Konstruktor jest to specjalna metoda klasy ktÃ³ra jest wywoÅ‚ywana automatycznie przy tworzeniu nowego obiektu. Jego gÅ‚Ã³wnym zadaniem jest inicjalizacja (czyli nadanie wartoÅ›ci) wÅ‚aÅ›ciwoÅ›ci obiektu.**

Konstruktor natomiast nie posiada Å¼adnego typu ani zakresu widocznoÅ›ci, ale ma tÄ… samÄ… nazwÄ™ co klasa w ktÃ³rej piszemy. Zapisuje siÄ™ go wewnÄ…trz klasy nastÄ™pujÄ…co.

```java
Counter(){
  
}
```

Jak juÅ¼ wczeÅ›niej siÄ™ dowiedzieliÅ›my sÅ‚uÅ¼y do inicjalizacji wÅ‚aÅ›ciwoÅ›ci obiektu. Czyli przypisania wartoÅ›ci (w trakcie tworzenia obiektu tej klasy) do juÅ¼ istniejÄ…cych zmiennych czekajÄ…cych na wartoÅ›Ä‡ wewnÄ…trz tej klasy.

>[!NOTE]
> KonstruktorÃ³w klasa moÅ¼e mieÄ‡ nieskoÅ„czenie wiele, mogÄ… rÃ³wnieÅ¼ byÄ‡ puste co by oznaczaÅ‚o, Å¼e nowÄ… klasÄ™ tworzymy bez przypisania Å¼adnych wartoÅ›ci i nie moÅ¼emy niÄ… "manipulowaÄ‡".
>
> JeÅ¼eli klasa ma kilka konstruktorÃ³w to mÃ³wimy, Å¼e taka klasa ma `przeciÄ…Å¼ony konstruktor`. Oznacza to, Å¼e moÅ¼emy stworzyÄ‡ klasÄ™ na kilka rÃ³Å¼nych sposobÃ³w, np. podajÄ…c rÃ³Å¼nego typu wartoÅ›ci.

<details>
  <summary> â„¹ï¸ PrzykÅ‚ad przeciÄ…Å¼enia konstruktora </summary>

```java
class Car {
    String brand;
    String model;
    int year;

    // ğŸ”¹ Konstruktor 1: DomyÅ›lny (bez parametrÃ³w)
    Car() {
        this.brand = "Nieznana";
        this.model = "Nieznany";
        this.year = 0;
    }

    // ğŸ”¹ Konstruktor 2: Dwa parametry
    Car(String brand, String model) {
        this.brand = brand;
        this.model = model;
        this.year = 2024;  // DomyÅ›lny rok
    }

    // ğŸ”¹ Konstruktor 3: Trzy parametry
    Car(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    void showInfo() {
        System.out.println("SamochÃ³d: " + brand + " " + model + " (" + year + ")");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car1 = new Car();  // UÅ¼ywa pierwszego konstruktora
        Car car2 = new Car("Toyota", "Corolla");  // UÅ¼ywa drugiego konstruktora
        Car car3 = new Car("Ford", "Mustang", 1969);  // UÅ¼ywa trzeciego konstruktora

        car1.showInfo();  // SamochÃ³d: Nieznana Nieznany (0)
        car2.showInfo();  // SamochÃ³d: Toyota Corolla (2024)
        car3.showInfo();  // SamochÃ³d: Ford Mustang (1969)
    }
}
```
  
</details>

WiÄ™c utwÃ³rzmy jakÄ…Å› wÅ‚aÅ›ciwoÅ›Ä‡ dla naszej klasy `Counter` i konstruktor do zainicjalizowania jej.
Naszymi wÅ‚aÅ›ciwoÅ›ciami bÄ™dÄ…:
- wartoÅ›Ä‡
- krok
- czyAktywny
- nazwa (bo chcemy go sobie nazwaÄ‡)

Nasz konstruktor powinien wyglÄ…daÄ‡ nastÄ™pujÄ…co.

![obraz](https://github.com/user-attachments/assets/be5e9f3b-7e0e-4bf2-8c55-3169a38eab74)

WewnÄ…trz konstruktora stosujemy sÅ‚Ã³wko kluczowe `this` odwoÅ‚ujÄ…ce siÄ™ do tej klasy, a po kropce moÅ¼emy odwoÅ‚aÄ‡ siÄ™ do wÅ‚aÅ›ciwoÅ›ci `TEJ` klasy. Dlatego teÅ¼ inicjalizacje czyli przypisanie moÅ¼emy rozumieÄ‡ w dosÅ‚owny sposÃ³b:
`ta wÅ‚aÅ›ciwoÅ›Ä‡ ma mieÄ‡ przypisanÄ… tÄ… wartoÅ›Ä‡` ktÃ³re zostanÄ… nadane przez programiste tworzÄ…cego klase.

### Metody

SÅ‚owo `metoda` padÅ‚o juÅ¼ kilkukrotnie, natomiast pÃ³Åºno zostanie wyjaÅ›nione z prostego zaÅ‚oÅ¼enia - Å¼e wy juÅ¼ wiecie.

>[!IMPORTANT]
>**Metoda - zestaw instrukcji, ktÃ³ry wykonuje okreÅ›lone zadanie za poÅ›rednictwem konkretnego obiektu klasy. MoÅ¼na jÄ… wywoÅ‚aÄ‡ wiele razy, co pozwala uniknÄ…Ä‡ powtarzania tego samego kodu w rÃ³Å¼nych miejscach programu.**

Aby utworzyÄ‡ metodÄ™ naleÅ¼y okreÅ›liÄ‡ przede wszystkim jej typ, ktÃ³ry musimy zwrÃ³ciÄ‡ na koÅ„cu jej dziaÅ‚ania.

W naszym przypadku bÄ™dzie to metoda pokazujÄ…ca nam wartoÅ›Ä‡ i powinna wyglÄ…daÄ‡ nastÄ™pujÄ…co

![obraz](https://github.com/user-attachments/assets/dcca2937-e16e-4aba-bbaf-99715f1cc36b)

>[!WARNING]
>W przypadku typu `void` nie potrzebujemy zwracaÄ‡ nic z naszej funkcji.
>
>A `System.out.println` wypisuje tekst do konsoli. 

**ğŸŒ  Zadania do wykonania**
- [ ] Napisz nowÄ… metodÄ™ dla klasy Counter, ktÃ³ra bÄ™dzie zwiÄ™kszaÅ‚a licznik o wartoÅ›Ä‡ kroku, tylko w przypadku jeÅ¼eli licznik jest aktywny.
- [ ] Napisz nowe metody dla klasy Counter, ktÃ³re zwrÃ³cÄ… wartoÅ›ci wÅ‚aÅ›ciwoÅ›ci klasy. Na kaÅ¼dÄ… wÅ‚aÅ›ciwoÅ›Ä‡ ma byÄ‡ jedna metoda.

### Gettery/Settery

W ostatnim zadaniu mieliÅ›my utworzyÄ‡ metody, ktÃ³re zwracajÄ… wartoÅ›Ä‡ poszczegÃ³lnych wÅ‚aÅ›ciwoÅ›ci - tym wÅ‚aÅ›nie sÄ… `gettery`.

>[!IMPORTANT]
>**Gettery i settery to metody dostÄ™powe, ktÃ³re pozwalajÄ… odczytywaÄ‡ i zmieniaÄ‡ wartoÅ›ci prywatnych pÃ³l klasy. DziÄ™ki nim moÅ¼emy kontrolowaÄ‡, jak modyfikowane sÄ… wÅ‚aÅ›ciwoÅ›ci obiektu.**

PrzykÅ‚adowy getter oraz setter dla wÅ‚aÅ›ciwoÅ›ci powinien wyglÄ…daÄ‡ nastÄ™pujÄ…co:

![obraz](https://github.com/user-attachments/assets/afcbfb53-2301-4bd2-ae6a-1fcc286ab3b3)

**ğŸŒ  Zadania do wykonania**
- [ ] StwÃ³rz resztÄ™ getterÃ³w i setterÃ³w dla wÅ‚aÅ›ciwoÅ›ci, pamiÄ™taj, Å¼e przedrostek dla getterÃ³w to `get` a dla setterÃ³w to `set` w celu Å‚atwego rozrÃ³Å¼nienia funkcjonalnoÅ›ci tych metod.
- [ ] Aby gettery i settery miaÅ‚y sens istnienia, pamiÄ™taj aby zmieniÄ‡ `scope` wÅ‚aÅ›ciwoÅ›ci na prywatny.

### Tworzenie obiektu

Aby faktycznie przedstawiÄ‡ istnieje obiektu na podstawie klasy Counter, naleÅ¼y go utworzyÄ‡ i wywoÅ‚aÄ‡.

Zrobimy to za pomocÄ… przycisku w naszej aplikacji.
- W pliku `MainActivity.java` utwÃ³rz nowÄ… metodÄ™ klasy o nazwie `createCounter(View view)`.
- NastÄ™pnie dodaj nowy przycisk do prostego widoku aplikacji i poÅ‚Ä…cz metodÄ™ `createCounter` z wÅ‚aÅ›ciwoÅ›ciÄ… `onClick` przycisku.

WewnÄ…trz metody `createCounter` utworzymy obiekt typu Counter w nastÄ™pujÄ…cy sposÃ³b i wywoÅ‚amy metodÄ™ obiektu `showValue`.

![obraz](https://github.com/user-attachments/assets/48867c82-7b52-42ff-bc11-8c69562da67a)

#### ğŸŒ  Zadania do wykonania
- UtwÃ³rz nowÄ… klasÄ™ w oddzielnym pliku o nazwie `PizzaFactory`, celem tej klasy jest moÅ¼liwoÅ›Ä‡ utworzenia obiektu `pizza`, ktÃ³ry bÄ™dzie mÃ³gÅ‚ mieÄ‡ okreÅ›lonÄ… wielkoÅ›Ä‡, nazwÄ™, wartoÅ›Ä‡ okreÅ›lajÄ…cÄ… czy jest bezglutenowa, bazowy sos, stan surowoÅ›ci pizzy oraz pustÄ… listÄ™ skÅ‚adnikÃ³w. ListÄ™ skÅ‚adnikÃ³w naleÅ¼y zaimplementowaÄ‡ za pomocÄ… metody.
- KaÅ¼dy ze skÅ‚adnikÃ³w bÄ™dzie dodany za pomocÄ… odpowiedniego przycisku w aplikacji.
- Przyciskami dodatkowymi bÄ™dzie moÅ¼na "podpiec pizzÄ™" w skali 1/10, kaÅ¼de klikniÄ™cie przycisku ma zwiÄ™kszaÄ‡ licznik i tym samym zmieniaÄ‡ stan pizzy przy konkretnych prograch.
- Ostatnim przyciskiem bÄ™dzie "wydanie pizzy" ktÃ³ry wyÅ›wietli wszystkie informacje o zaserwowanej pizzy w Å‚adny sposÃ³b na konsoli `Logcat`.

>[!NOTE]
> Klasa ma zawieraÄ‡ wszystkie metody, gettery, settery oraz 3 przeciÄ…Å¼one konstruktury!


## Dziedziczenie

>[!IMPORTANT]
>**Dziedziczenie to mechanizm, ktÃ³ry pozwala tworzyÄ‡ nowe klasy w oparciu o juÅ¼ istniejÄ…ce. DziÄ™ki niemu nowa klasa (tzw. podklasa lub klasa potomna) przejmuje wÅ‚aÅ›ciwoÅ›ci i metody klasy nadrzÄ™dnej (superklasy).**

PrzykÅ‚adem wykorzystania mechanizmu dziedziczenia bÄ™dzie utworzenie dwÃ³ch klas, jednej bazowej i ogÃ³lnej z ktÃ³rej to bÄ™dzie moÅ¼na utworzyÄ‡ bardziej specyficzne klasy tak jak w przykÅ‚adzie poniÅ¼ej.
Na podstawie klasy bazowej moÅ¼na utworzyÄ‡ wiele klas dziedziczÄ…cych
```java
public class Animal {
    public void sound() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    public void bark() {
        System.out.println("Woof woof!");
    }
}
public class Cat extends Animal {
    public void meow() {
        System.out.println("Meow uwu!");
    }
}
public class Alien extends Animal{
    @Override
    public void sound() {
        System.out.println("bogos binted? ğŸ‘½");
    }
}
```

>[!NOTE]
> Dekorator `@Override` pozwala nam nadpisaÄ‡ metodÄ™ klasy bazowej.

Jednak wykorzystywanie w ten sposÃ³b dziedziczenia byÅ‚oby marnowaniem zasobÃ³w naszych szarych komÃ³rek oraz tlenu. Dlatego teÅ¼ gdy juÅ¼ prosty przykÅ‚ad mamy za sobÄ… pora na przypadek z prawdziwego zdarzenia.


```java
class Vehicle {
    protected String brand;
    protected int year;

    public Vehicle(String brand, int year) {
        this.brand = brand;
        this.year = year;
    }

    public void start() {
        System.out.println(brand + " uruchamia silnik.");
    }

    public void stop() {
        System.out.println(brand + " zatrzymuje siÄ™.");
    }

    public void displayInfo() {
        System.out.println("Marka: " + brand + ", Rok produkcji: " + year);
    }
}

// Klasa Car dziedziczÄ…ca po Vehicle
class Car extends Vehicle {
    private int doors;

    public Car(String brand, int year, int doors) {
        super(brand, year);
        this.doors = doors;
    }

    public void honk() {
        System.out.println(brand + " trÄ…bi: Beep beep!");
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Liczba drzwi: " + doors);
    }
}

// Klasa Motorcycle dziedziczÄ…ca po Vehicle
class Motorcycle extends Vehicle {
    private boolean hasSidecar;

    public Motorcycle(String brand, int year, boolean hasSidecar) {
        super(brand, year);
        this.hasSidecar = hasSidecar;
    }

    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Ma boczny wÃ³zek: " + (hasSidecar ? "Tak" : "Nie"));
    }
}
```

Z pewnoÅ›ciÄ… zauwaÅ¼yÅ‚*Å› takÄ… dziwnÄ… funkcjÄ™ `super()`, ktÃ³ra pojawia siÄ™ w konstruktorach oraz metodach klas potomnych.
>[!NOTE]
> Funkcja `super()` odnosi siÄ™ do **konstruktora klasy bazowej** i sÅ‚uÅ¼y do jego wywoÅ‚ania wewnÄ…trz konstruktora klasy pochodnej.
>
> Potrzebne jest to z powodu mechanizmu dziedziczenia, w trakcie ktÃ³rego klasa bazowa najpierw musi zostaÄ‡ utworzona, aby klasa pochodna mogÅ‚a zaistnieÄ‡.
>
> Dlatego teÅ¼ konstruujÄ…c klasÄ™ potomnÄ… naleÅ¼y **ZAINICJOWAÄ†** klasÄ™ bazowÄ…, specjalnÄ… funkcjÄ… `super()`. PodajÄ…c jej argumenty takie jakich konstruktor wymaga.
>
> W przypadku wywoÅ‚ania `super.displayInfo()` oznacza to, Å¼e wywoÅ‚ujemy **metodÄ™ klasy bazowej**, a nie klasy potomnej w ktÃ³rej wywoÅ‚ywana jest ta funkcjonalnoÅ›Ä‡.



W celu wywoÅ‚ania tych klas bÄ™dziemy wykorzystywaÄ‡ klasÄ™ bazowÄ… dla klas potomnych.

NaleÅ¼y zwrÃ³ciÄ‡ uwagÄ™ na typ klasy, jest `Vehicle` i nie jest on bez powodu zastosowany. Pozwala on na bezpoÅ›rednie ujednolicenie obiektÃ³w do klasy bazowej, mimo wykorzystania rÃ³Å¼nych "odnÃ³g" klas potomnych.

Natomiast nic nie stoi nam na przeszkodzie, abyÅ›my wywoÅ‚ywali klasy potomne wedÅ‚ug ich pierwotnego typu i mieli bezpoÅ›redni dostÄ™p bez `rzutowania` typÃ³w do ich metod.

```java
Vehicle myCar = new Car("Toyota", 2022, 4);
Vehicle myMotorcycle = new Motorcycle("Harley-Davidson", 2021, false);

// WywoÅ‚anie metod dla rÃ³Å¼nych typÃ³w pojazdÃ³w
myCar.start();
myCar.displayInfo();
((Car) myCar).honk(); // Rzutowanie do Car, aby uÅ¼yÄ‡ metody honk()

myMotorcycle.start();
myMotorcycle.displayInfo();
```

**ğŸŒ  Zadania do wykonania**

0. StwÃ³rz klasÄ™ bazowÄ… Vehicle, ktÃ³ra zawiera:
   - Pole speed (prÄ™dkoÅ›Ä‡ pojazdu).
   - Pole capacity (liczba pasaÅ¼erÃ³w).
   - MetodÄ™ displayInfo(), ktÃ³ra wyÅ›wietli informacje o pojeÅºdzie.
   - UtwÃ³rz trzy klasy potomne, dziedziczÄ…ce po Vehicle:
     - Car â€“ dodaj pole fuelType (np. benzyna, diesel, elektryczny).
     - Bicycle â€“ dodaj pole hasBell (czy ma dzwonek, true/false).
     - Boat â€“ dodaj pole waterType (np. â€sÅ‚odkowodnyâ€, â€morskiâ€).
     - W kaÅ¼dej podklasie nadpisz metodÄ™ displayInfo(), by uwzglÄ™dniaÅ‚a unikalne cechy klasy.
       
1. UtwÃ³rz klasÄ™ bazowÄ… `Animal`, ktÃ³ra posiada wÅ‚aÅ›ciwoÅ›ci `name`, `species`, `age`.
   - Dodatkowo podstawowÄ… metodÄ™ `makeSound()` oraz `displayInfo`, ktÃ³ra bÄ™dzie dla kaÅ¼dego zwierzÄ™cia nadpisywana i zmieniana.
   - Kolejnym krokiem bÄ™dzie utworzenie klas pochodnych, ktÃ³re majÄ… byÄ‡ nastÄ™pujÄ…ce `Mammal` z polami `furColor`, `furType`; `Bird` z polami `wingSpan`, `lifeCycle`; `Reptile` z polem `isVenomous`.
   - Dodaj kaÅ¼dej klasie potomnej po dwie metody wÅ‚asne.
2. StwÃ³rz interfejs aplikacji mobilnej pozwalajÄ…cy zmodyfikowaÄ‡ i utworzyÄ‡ poszczegÃ³lnÄ… klasÄ™ potomnÄ… oraz jÄ… finalnie wypisaÄ‡ w konsoli.

---

<h3>

âœ¨ Zadanie dodatkowe - `System zarzÄ…dzania kursami`

</h3>

>[!NOTE]
> â„¹ï¸ <ins>NaleÅ¼y na poczÄ…tku pliku dodaÄ‡ import: `import java.util.*`, ktÃ³ry importuje potrzebne nam obiekty `Map` oraz `List`.</ins>
>
> â„¹ï¸ W zadaniu wystÄ™puje klasa abstrakcyjna, ktÃ³rej wczeÅ›niej nie omawialiÅ›my na zajÄ™ciach. Klasa abstrakcyjna to taka, ktÃ³ra sÅ‚uÅ¼y tylko i wyÅ‚Ä…cznie do dziedziczenia - <ins>wiÄ™c nie moÅ¼na utworzyÄ‡ z niej obiektu</ins>, posiada konstruktor oraz metody, a takÅ¼e mogÄ… wystÄ™powaÄ‡ w niej `metody abstrakcyjne` czyli takie, ktÃ³re zostaÅ‚y jedynie zadeklarowane, ale nie posiadajÄ… Å¼adnego kodu - sÅ‚uÅ¼Ä… do nadpisania przez klasy dziedziczÄ…ce, natomiast rÃ³wnieÅ¼ wystÄ™pujÄ… z modyfikatorem `abstract`.
>
>   - WyglÄ…da ona nastÄ™pujÄ…co:
>     
>     ![obraz](https://github.com/user-attachments/assets/0f797a9a-b217-4ef8-a737-071a1885277b)
>
> â¡ï¸ **List** - przydatne informacje
> - [x] Utworzenie list wyglÄ…da nastÄ™pujÄ…co: `List<Student> students = new ArrayList<>();`
> - [x] Posiada metody takie jak:
>       
>   - `students.add(element)` â€“ dodaje element,
>   - `students.remove(element)` â€“ usuwa element,
>   - `students.get(index)` â€“ pobiera element o danym indeksie,
>   - `students.contains(element)` â€“ sprawdza, czy lista zawiera element,
>   - `students.size()` â€“ zwraca iloÅ›Ä‡ elementÃ³w.
> - [ ] Iterowanie po list: `students.forEach(student -> System.out.println("student: " + student.getName()));`
>  
> â¡ï¸ **Map** - przydatne informacje
> - [x] Utworzenie map wyglÄ…da nastÄ™pujÄ…co: `Map<Student, String> submissions = new HashMap<>();`
> - [x] Posiada metody takie jak:
>
>   - `submissions.put(key, value)` â€“ dodaje lub nadpisuje wartoÅ›Ä‡ pod kluczem,
>   - `submissions.get(key)` â€“ zwraca wartoÅ›Ä‡ przypisanÄ… do klucza,
>   - `submissions.containsKey(key)` â€“ sprawdza, czy dany klucz istnieje,
>   - `submissions.remove(key)` â€“ usuwa parÄ™,
>   - `submissions.entrySet()` â€“ zbiÃ³r wszystkich par, np. do wypisywania.
> - [ ] Iterowanie po map: `submissions.forEach((student, content) -> System.out.println(student.getName() + " content: " + content));`


1. UtwÃ³rz `abstrakcyjnÄ…` klasÄ™ `User`
   - Pola ktÃ³re posiada: `String name`, `String email`.
   - UtwÃ³rz `gettery` i `settery` pÃ³l wraz z konstruktorem, oraz abstrakcyjna metoda `String getRole()`, ktÃ³ra bÄ™dzie nadpisywana w klasie `Teacher` oraz `Student` i zwracaÅ‚a ciÄ…g znakÃ³w `Teacher` lub `Student`.
2. UtwÃ³rz klasÄ™ `Student` dziedziczÄ…cÄ… po klasie `User`
   - Pola inicjujÄ…ce muszÄ… byÄ‡ zastosowane wedÅ‚ug klasy dziedziczÄ…cej, oraz dodatkowo muszÄ… pojawiÄ‡ siÄ™ pola `int index` oraz `List<Course> joinedCourses`.
   - Metody ktÃ³re sÄ… wymagane przez tÄ™ klasÄ™ sÄ… nastÄ™pujÄ…ce:
     - `joinCourse(Course course)` - dodaje kurs do listy oraz informuje obiekt Course, Å¼e student siÄ™ zapisaÅ‚,
     - `listCourses()` - wypisuje wszystkie kursy, na ktÃ³re student jest zapisany,
     - `submitAssignment(Course course, Assignment assignment, String content)` - zgÅ‚asza rozwiÄ…zanie danego zadania przypisanego do danego kursu.
3. UtwÃ³rz klasÄ™ `Teacher` dziedziczÄ…cÄ… po klasie `User`
   - Inicjacja pÃ³l musi wyglÄ…daÄ‡ podobnie jak w przypadku klasy `Student` czyli `List<Course> teachingCourses`, jednak tym razem bez pola `int index`.
   - Metody ktÃ³re posiada ta klasa to:
     - `createCourse(String title)` - tworzy nowy kurs, przypisuje siebie jako instruktora i dodaje do swojej listy,
     - `addAssignment(Course course, Assignment assignment)` - dodaje zadanie do konkretnego kursu tylko jeÅ›li jest jego instruktorem.
1. UtwÃ³rz klasÄ™ `Course`
   - Pola ktÃ³re posiada: `String title`, `Teacher teacher`, `List<Student> students`, `List<Assignment> assignments`.
   - Metody ktÃ³re potrzebuje posiadaÄ‡ klasa:
     - `addStudent(Student student)` -  dodaje studenta do listy uczestnikÃ³w,
     - `addAssignment(Assignment assignment)` - dodaje zadanie do listy zadaÅ„,
     - `listAssignments()` - wypisuje wszystkie zadania przypisane do kursu,
     - `listStudents()` - wypisuje wszystkich studentÃ³w przypisanych do kursu.
5. UtwÃ³rz klasÄ™ `Assignment`
   - Pola do zainicjowania sÄ… nastÄ™pujÄ…ce: `String title`, `String description`,`Map<Student, String> submissions`,`Map<Student, Integer> grades`.
   - Metody potrzebne tej klasie to:
     - `submit(Student student, String content)`- dodaje zgÅ‚oszenie do mapy `submissions`,
     - `getSubmission(Student student)` - zwraca zgÅ‚oszenie konkretnego studenta,
     - `gradeSubmission(Student student, int grade)`- przypisuje ocenÄ™ za zadanie,
     - `listAllSubmissions()`- wypisuje wszystkich studentÃ³w, ktÃ³rzy przesÅ‚ali zadanie.

Logika funkcjonalnoÅ›ci zadania:
- Instruktor tworzy obiekt Instructor, np. `new Teacher("Anna", "anna@uni.edu")`
- Anna tworzy kurs: `Course javaCourse = anna.createCourse("Java 101")`
- Student Marek tworzy obiekt: `Student marek = new Student("Marek", "marek@gmail.com")`
- Marek zapisuje siÄ™ na kurs: `marek.joinCourse(javaCourse)`
- Anna tworzy zadanie: `Assignment task1 = new Assignment("Zadanie 1", "Zaimplementuj klasÄ™ Vehicle")`
- Anna dodaje zadanie do kursu: `anna.addAssignment(javaCourse, task1)`
- Marek przesyÅ‚a rozwiÄ…zanie: `marek.submitAssignment(javaCourse, task1, "public class Vehicle {...}")`
- Anna ocenia zadanie: `task1.gradeSubmission(marek, 5)`
- Zadanie potrafi wypisaÄ‡ wszystkie zgÅ‚oszenia i oceny.

---

### ğŸ“š Zadanie dodatkowe - System wypoÅ¼yczania ksiÄ…Å¼ek w bibliotece


StwÃ³rz aplikacjÄ™, ktÃ³ra symuluje prosty system biblioteczny, umoÅ¼liwiajÄ…cy:
- dodawanie ksiÄ…Å¼ek przez bibliotekarzy,
- wypoÅ¼yczanie i zwracanie ksiÄ…Å¼ek przez czÅ‚onkÃ³w,
- zarzÄ…dzanie ksiÄ…Å¼kami i ich stanem dostÄ™pnoÅ›ci.
- sprawdzeniem historii wypoÅ¼yczeÅ„ danej osoby.

> [!NOTE]
> Na poczÄ…tku pliku naleÅ¼y dodaÄ‡:
> 
> ```java
> import java.util.*;
> ```
> 
> Importuje to potrzebne klasy z kolekcji Java (`List`, `Map`, `ArrayList`, `HashMap` itd.).
>
> Przy tworzeniu list pamiÄ™taj:
>  ```java
>  List<Book> books = new ArrayList<>();
>  ```
>
>  Sprawdzanie dostÄ™pnoÅ›ci ksiÄ…Å¼ki moÅ¼e wyglÄ…daÄ‡ tak:
>  ```java
>  if (book.isAvailable()) {
>      // moÅ¼na wypoÅ¼yczyÄ‡
>  }
>  ```


### 1. Abstrakcyjna klasa `Person`
SÅ‚uÅ¼y jako podstawa dla uÅ¼ytkownikÃ³w systemu.

**Pola:**
- `String name`
- `String id`

**Metody:**
- Konstruktor i gettery/settery
- Abstrakcyjna metoda:
  ```java
  public abstract String getRole();
  ```

### 2. Klasa `Member` (dziedziczy po `Person`)
Reprezentuje osobÄ™ wypoÅ¼yczajÄ…cÄ… ksiÄ…Å¼ki.

**Dodatkowe pole:**
- `List<Book> borrowedBooks`

**Metody:**
- `void borrowBook(Book book)` - Dodaje ksiÄ…Å¼kÄ™ do listy wypoÅ¼yczonych (jeÅ›li jest dostÄ™pna i nie przekroczono limitu 3).
- `void returnBook(Book book)` - Usuwa ksiÄ…Å¼kÄ™ z listy wypoÅ¼yczonych i ustawia jej stan jako dostÄ™pny.
- `void listBorrowedBooks()` - Wypisuje wszystkie aktualnie wypoÅ¼yczone ksiÄ…Å¼ki.

### 3. Klasa `Librarian` (dziedziczy po `Person`)
Reprezentuje bibliotekarza zarzÄ…dzajÄ…cego ksiÄ…Å¼kami.

**Dodatkowe pole:**
- `List<Book> managedBooks`

**Metody:**
- `Book addBook(String title, String author)` - Tworzy nowÄ… ksiÄ…Å¼kÄ™ i przypisuje jÄ… do siebie.
- `void removeBook(Book book)` - Usuwa ksiÄ…Å¼kÄ™ z listy (opcjonalne: tylko jeÅ›li nie jest wypoÅ¼yczona).
- `void listManagedBooks()` - Wypisuje wszystkie ksiÄ…Å¼ki, ktÃ³rymi zarzÄ…dza.


### 4. Klasa `Book`
Reprezentuje ksiÄ…Å¼kÄ™ w bibliotece.

**Pola:**
- `String title`
- `String author`
- `Librarian librarian`
- `Member borrower` (moÅ¼e byÄ‡ `null`)
- `Map<Member, String> history` â€“ historia wypoÅ¼yczeÅ„ (klucz: czÅ‚onek, wartoÅ›Ä‡: data)

**Metody:**
- `void assignToLibrarian(Librarian librarian)`
- `boolean borrow(Member member)` â€“ WypoÅ¼ycza ksiÄ…Å¼kÄ™, ustawia `borrower`, zapisuje do historii. Zwraca `true`, jeÅ›li siÄ™ powiodÅ‚o, `false`, jeÅ›li ksiÄ…Å¼ka jest juÅ¼ zajÄ™ta.
- `void returnBook()` -  Ustawia `borrower = null`, czyli zwraca ksiÄ…Å¼kÄ™.
- `boolean isAvailable()` - Zwraca `true`, jeÅ›li `borrower == null`.
- `void getInfo()` â€“ Wypisuje tytuÅ‚, autora, status ksiÄ…Å¼ki i kto wypoÅ¼yczyÅ‚.
- `void addToHistory(Member member)` - dodaje do historii czÅ‚onka biblioteki przy danej ksiÄ…Å¼ce wraz z czasem wypoÅ¼yczenia.
- `void printHistory()` - wyÅ›wietla caÅ‚Ä… historiÄ™ posiadaczy ksiÄ…Å¼ki

>[!WARNING]
> - [x] Jedna ksiÄ…Å¼ka moÅ¼e byÄ‡ przypisana tylko do jednego bibliotekarza.
>
> - [x] CzÅ‚onek moÅ¼e wypoÅ¼yczyÄ‡ maksymalnie 3 ksiÄ…Å¼ki jednoczeÅ›nie.
>
> - [x] Historia wypoÅ¼yczeÅ„ powinna byÄ‡ zachowana i wypisywana na Å¼Ä…danie.
>
> - [x] KsiÄ…Å¼ka wypoÅ¼yczona przez jednego czÅ‚onka nie moÅ¼e byÄ‡ wypoÅ¼yczona przez innego, dopÃ³ki nie zostanie zwrÃ³cona.


### PrzykÅ‚adowy scenariusz uÅ¼ycia
```java
// Tworzenie bibliotekarza
Librarian jan = new Librarian("Jan", "L001");

// Bibliotekarz dodaje ksiÄ…Å¼ki
Book book1 = jan.addBook("WiedÅºmin", "Andrzej Sapkowski");
Book book2 = jan.addBook("Lalka", "BolesÅ‚aw Prus");
Book book3 = jan.addBook("Hobbit", "J.R.R. Tolkien");
Book book4 = jan.addBook("Zbrodnia i kara", "Fiodor Dostojewski");

// Sprawdzenie listy ksiÄ…Å¼ek zarzÄ…dzanych przez bibliotekarza
jan.listManagedBooks();

// Tworzenie czÅ‚onkÃ³w
Member aga = new Member("Agnieszka", "M123");
Member tomek = new Member("Tomek", "M124");

// Aga wypoÅ¼ycza 3 ksiÄ…Å¼ki
aga.borrowBook(book1);
aga.borrowBook(book2);
aga.borrowBook(book3);

// PrÃ³ba wypoÅ¼yczenia czwartej ksiÄ…Å¼ki przez AgÄ™ â€“ powinno siÄ™ nie udaÄ‡
aga.borrowBook(book4); // Oczekiwany komunikat: "Nie moÅ¼esz wypoÅ¼yczyÄ‡ wiÄ™cej niÅ¼ 3 ksiÄ…Å¼ki!"

// Aga wypisuje swoje wypoÅ¼yczone ksiÄ…Å¼ki
aga.listBorrowedBooks();

// Tomek wypoÅ¼ycza 1 ksiÄ…Å¼kÄ™
tomek.borrowBook(book4);

// Sprawdzenie statusu ksiÄ…Å¼ek
book1.getInfo(); //  WypoÅ¼yczona przez AgnieszkÄ™
book4.getInfo(); //  WypoÅ¼yczona przez Tomka

// Aga zwraca ksiÄ…Å¼kÄ™
aga.returnBook(book1);

// Ponowna prÃ³ba wypoÅ¼yczenia czwartej ksiÄ…Å¼ki
aga.borrowBook(book4); // Oczekiwany bÅ‚Ä…d

// Historia wypoÅ¼yczeÅ„ ksiÄ…Å¼ki "Zbrodnia i kara"
book4.printBorrowHistory(); 
// > Tomek - 2025-04-23
// > Agnieszka - 2025-04-23 (drugi wypoÅ¼yczyÅ‚a po zwrocie Tomka)

tomek.returnBook(book4);

// Aga oddaje wszystkie ksiÄ…Å¼ki
aga.returnBook(book2);
aga.returnBook(book3);
aga.returnBook(book4);

// Ponowne wypoÅ¼yczenie przez Tomka
tomek.borrowBook(book4);

// Finalna historia ksiÄ…Å¼ki
book4.printBorrowHistory();
// > Tomek - ...
// > Agnieszka - ...
// > Tomek - ...
```

---

# Zadanie - Ekran bloga
UÅ‚Ã³Å¼ ekran wedÅ‚ug przedstawionego widoku 

<img src='https://github.com/user-attachments/assets/bd47066d-4655-4d8a-af78-457fdcfcf28f' width="50%" />

## ğŸ“° Zadanie dodatkowe - System zarzÄ…dzania wiadomoÅ›ciami w aplikacji newsowej

StwÃ³rz aplikacjÄ™ w Javie, ktÃ³ra symuluje system zarzÄ…dzania wiadomoÅ›ciami, umoÅ¼liwiajÄ…cy:

- dodawanie newsÃ³w przez redaktorÃ³w,
- przeglÄ…danie wiadomoÅ›ci przez uÅ¼ytkownikÃ³w,
- oznaczanie przeczytanych wiadomoÅ›ci,
- przeglÄ…danie listy nieprzeczytanych wiadomoÅ›ci,
- filtrowanie wiadomoÅ›ci po kategoriach (np. `BIG NEWS`, `TALLEST MAN`, `NEW UFO?`).

> [!NOTE] 
> PamiÄ™taj aby kaÅ¼dej klasie przypisaÄ‡ dodatkowÄ… metodÄ™ wypisujÄ…cÄ… informacje ktÃ³re zachowuje w polach!

---

### 1. Abstrakcyjna klasa `User`
SÅ‚uÅ¼y jako baza dla uÅ¼ytkownikÃ³w systemu.

**Pola:**
- `String name`
- `String id`

**Metody:**
- Konstruktor, gettery/settery
- Abstrakcyjna metoda:
  ```java
  public abstract String getRole();
  ```


### 2. Klasa `Editor` (dziedziczy po `User`)
Reprezentuje redaktora, ktÃ³ry dodaje wiadomoÅ›ci.

**Dodatkowe pole:**
- `List<News> publishedNews`

**Metody:**
- `News publishNews(String title, String content, String category)` - tworzy i dodaje nowy news.
- `void listPublishedNews()` - wypisuje opublikowane wiadomoÅ›ci.


### 3. Klasa `Reader` (dziedziczy po `User`)
Reprezentuje uÅ¼ytkownika przeglÄ…dajÄ…cego wiadomoÅ›ci.

**Dodatkowe pola:**
- `List<News> readNews`

**Metody:**
- `void readNews(News news)` - oznacza wiadomoÅ›Ä‡ jako przeczytanÄ….
- `void listUnreadNews(List<News> allNews)` - wypisuje wiadomoÅ›ci nieprzeczytane.
- `void filterNewsByCategory(List<News> allNews, String category)` - wypisuje wiadomoÅ›ci wg kategorii.



### 4. Klasa `News`
Reprezentuje pojedynczy news.

**Pola:**
- `String title`
- `String content`
- `String category` (np. `BIG NEWS`, `TALLEST MAN`, `NEW UFO?`)
- `Editor editor`
- `Date date`

**Metody:**
- `void getInfo()` â€“ wypisuje tytuÅ‚, kategoriÄ™, autora i datÄ™.
- `String getCategory()`
- `String getTitle()`


### PrzykÅ‚adowy scenariusz uÅ¼ycia

```java
// Tworzenie redaktora
Editor anna = new Editor("Anna", "E001");

// Redaktor publikuje wiadomoÅ›ci
News n1 = anna.publishNews("BIG NEWS", "Something huge happened...", "BIG NEWS");
News n2 = anna.publishNews("Tallest man alive", "Record-breaking height!", "TALLEST MAN");
News n3 = anna.publishNews("UFO sighting?", "Residents report strange lights.", "NEW UFO?");

// Lista wszystkich wiadomoÅ›ci
List<News> allNews = new ArrayList<>();
allNews.add(n1);
allNews.add(n2);
allNews.add(n3);

// Tworzenie uÅ¼ytkownika
Reader jan = new Reader("Jan", "R101");

// Jan czyta jednÄ… wiadomoÅ›Ä‡
jan.readNews(n2);

// Jan wypisuje nieprzeczytane wiadomoÅ›ci
jan.listUnreadNews(allNews);

// Jan filtruje wiadomoÅ›ci z kategorii "BIG NEWS"
jan.filterNewsByCategory(allNews, "BIG NEWS");
```

### ğŸ”’ Zasady dziaÅ‚ania systemu:

- [x] WiadomoÅ›Ä‡ moÅ¼e byÄ‡ przeczytana tylko raz i zapisywana w liÅ›cie `readNews`.
- [x] Kategorie muszÄ… byÄ‡ obsÅ‚ugiwane dynamicznie jako `String`, ale moÅ¼esz je przechowywaÄ‡ w ustalonych wartoÅ›ciach.
- [x] `listUnreadNews` powinno ignorowaÄ‡ przeczytane przez danego uÅ¼ytkownika wiadomoÅ›ci.
- [x] Wszystkie klasy powinny mieÄ‡ czytelne metody `getInfo()` lub `toString()`.

---

## ğŸ”Œ Implementacja interfejsÃ³w

W Javie interfejs to rodzaj "kontraktu", ktÃ³ry okreÅ›la jakie metody klasa powinna posiadaÄ‡, ale nie definiuje ich dziaÅ‚ania. DziÄ™ki interfejsom moÅ¼emy pisaÄ‡ bardziej elastyczny i modularny kod, ktÃ³ry Å‚atwo rozszerzyÄ‡ bez zmian w istniejÄ…cych klasach.

> [!NOTE]
> **Interfejs**
> 
> Zawiera tylko nagÅ‚Ã³wki metod (chyba Å¼e sÄ… to metody default lub static).
> Klasa moÅ¼e implementowaÄ‡ wiele interfejsÃ³w (Java nie pozwala na dziedziczenie wielu klas).
> Pozwala na osiÄ…gniÄ™cie polimorfizmu â€“ moÅ¼emy traktowaÄ‡ rÃ³Å¼ne obiekty tak samo, jeÅ›li implementujÄ… ten sam interfejs.

```java
interface Animal {
    void makeSound();
}

class Dog implements Animal {
    public void makeSound() {
        System.out.println("Woof!");
    }
}

class Cat implements Animal {
    public void makeSound() {
        System.out.println("Meow!");
    }
}

// PrzykÅ‚ad polimorfizmu
public class Main {
    public static void main(String[] args) {
        Animal a1 = new Dog();
        Animal a2 = new Cat();
        
        a1.makeSound(); // Woof!
        a2.makeSound(); // Meow!
    }
}

```

### Zadanie do wykonania

StwÃ³rz aplikacjÄ™ w Javie, ktÃ³ra modeluje system powiadomieÅ„ obsÅ‚ugujÄ…cy rÃ³Å¼ne typy komunikacji (np. email, SMS, push), i pozwala uÅ¼ytkownikom je odbieraÄ‡ i zarzÄ…dzaÄ‡ nimi.

Twoim celem jest:
- uÅ¼ycie interfejsÃ³w do oddzielenia zachowaÅ„ nadawania/odbierania powiadomieÅ„,
- zastosowanie dziedziczenia dla rÃ³Å¼nych typÃ³w uÅ¼ytkownikÃ³w,
- wprowadzenie polimorfizmu w wysyÅ‚aniu i odbieraniu wiadomoÅ›ci.


### 1. Interfejs `Notifiable`
Reprezentuje wszystkie obiekty, ktÃ³re mogÄ… odbieraÄ‡ powiadomienia.

**Metody:**
  ```java
void receiveNotification(Notification notification);
List<Notification> getNotificationHistory();
void listNotificationsByType(String type);
  ```


### 2. Interfejs `NotificationSender`
OkreÅ›la sposÃ³b wysyÅ‚ania powiadomieÅ„.

**Metody:**
```java
Notification sendNotification(String message, Notifiable recipient);
String getType();
```


### 3. Abstrakcyjna klasa `User` implementuje `Notifiable`
Reprezentuje uÅ¼ytkownika aplikacji (bazowa klasa dla konkretnych typÃ³w uÅ¼ytkownikÃ³w).

**Pola**:

- String `name`
- String `id`
- List<Notification> `receivedNotifications`

**Metody**:

- Implementacja `receiveNotification i getNotificationHistory
- void `listNotificationsByType(String type)`
- abstract String `getUserType()`;
- void `getInfo()` â€“ wypisuje dane uÅ¼ytkownika.

### 4. Klasy dziedziczÄ…ce po User

- `RegularUser` : ZwykÅ‚y uÅ¼ytkownik koÅ„cowy. MoÅ¼e tylko odbieraÄ‡ powiadomienia.
- `AdminUser` : MoÅ¼e odbieraÄ‡ powiadomienia i tworzyÄ‡ nowe typy nadawcÃ³w (np. nowe kanaÅ‚y wysyÅ‚ki).

Dodatkowe metody:

- void `addSender(NotificationSender sender)`

- List<NotificationSender> `getAvailableSenders()`
  
### 5. Klasy wysyÅ‚ajÄ…ce powiadomienia (implementujÄ… NotificationSender):

- EmailSender
- SmsSender
- PushSender

ğŸˆ KaÅ¼da klasa musi:

- mieÄ‡ swojÄ… nazwÄ™ typu (`EMAIL`, `SMS`, `PUSH`)
- tworzyÄ‡ obiekt `Notification` i przekazywaÄ‡ go do recipient.receiveNotification(...)

### 6. Klasa Notification
Reprezentuje pojedyncze powiadomienie.

**Pola**:
- String `message`
- String `type`
- Date `date`
- String `senderType`

**Metody**:
- void `getInfo()` â€“ wypisuje treÅ›Ä‡, typ, datÄ™ i nadawcÄ™ powiadomienia.

### PrzykÅ‚adowy scenariusz uÅ¼ycia

```java
// Tworzymy uÅ¼ytkownikÃ³w
AdminUser admin = new AdminUser("Admin", "A001");
RegularUser user = new RegularUser("Kasia", "U100");

// Tworzymy nadawcÃ³w
NotificationSender emailSender = new EmailSender();
NotificationSender smsSender = new SmsSender();

// Admin konfiguruje dostÄ™pnych nadawcÃ³w
admin.addSender(emailSender);
admin.addSender(smsSender);

// Admin wysyÅ‚a powiadomienia
admin.getAvailableSenders().get(0).sendNotification("Welcome!", user);
admin.getAvailableSenders().get(1).sendNotification("2FA Code: 123456", user);

// UÅ¼ytkownik przeglÄ…da historiÄ™
user.getNotificationHistory().forEach(Notification::getInfo);

// Filtrowanie po typie
user.listNotificationsByType("EMAIL");
```

### ğŸˆ PamiÄ™taj Å¼e:
- **Zastosuj co najmniej 2 interfejsy (Notifiable, NotificationSender).**
- **UÅ¼yj dziedziczenia w klasach uÅ¼ytkownikÃ³w (User, AdminUser, RegularUser).**
- **Zademonstruj polimorfizm przy uÅ¼yciu listy obiektÃ³w implementujÄ…cych ten sam interfejs.**
- **KaÅ¼da klasa ma metodÄ™ getInfo() wypisujÄ…cÄ… dane.**

---

### Another TODOApp

- Wykonaj ukÅ‚ad w pliku XML aplikacji android
- âœ¨ Zaimplementuj funkcjonalnoÅ›Ä‡ aplikacji wedÅ‚ug zaÅ‚oÅ¼eÅ„ aplikacji TODO
   
![iPhone 14   15 Pro - 1](https://github.com/user-attachments/assets/5a35c3c8-4b05-45ac-be73-fb5f615cc648)

