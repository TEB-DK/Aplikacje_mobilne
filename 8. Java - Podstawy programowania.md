# <img src='https://www.svgrepo.com/show/452234/java.svg' height="36" align="top"> Java

Podstawy programowania w Javie zaczniemy w pliku `MainActivity.java`.
Nasz plik powinien zawierać główną klase wywołującą aplikacje mobilną.
```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_main);
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
            return insets;
        });
    }
}
```

Klasa ta jest "rozwija" czyli dziedziczy po klasie `AppCompatActivity` pewnie właściwości i metody, które mogą być nadpisane i to właśnie dzieje się w przypadku metody `onCreate`.
Poprzedza ją adnotacja, tak zwany `dekorator` @Override. Służy on by zadeklarować, iż dana dziedziczona metoda będzie nadpisana nową funkcjonalnością. Ale do szczegółów przejdziemy później.

Metoda ta wykonuje pewne zadania zaraz po utworzeniu widoku naszej aplikacji. Głównie ustawia opcję `EdgeToEdge`, następnie główny ekran zawierający kontent widoku oraz odpowiednie paddingi.

### Klasy

Same podstawy rozpoczniemy od zrozumienia i napisania swojej pierwszej klasy.

W drzewie plików po lewej stronie:
- Kliknij `prawym` na pakiet utworzonej aplikacji, `app -> java -> com.example.[nazwaaplikacji]`
- Wybierz pole `New`
- Wybierz pole `Java class`
- Nadaj nazwe swojej klasie, w naszym przypadku `Counter` i wciśnij `Enter`

Nasza nowa klasa powinna wyglądać tak:

![obraz](https://github.com/user-attachments/assets/2b613189-be6d-477d-ada0-533447cc0da6)

Każda klasa może zawierać następujące elementy:
- Właściwości
- Konstruktory
- Metody
- Settery/Gettery
- Główną metodę wywołującą działanie klasy.

#### Modyfikatory
Każdą właściwość powinno poprzedzać: `modyfikator` oraz `typ`.

Modyfikator widoczności lub zakres (z ang. `scope`) właściwości jak i metod (ponieważ do nich również się tyczą) dzielą się następująco: 

|            | Klasa | Pakiet | Podklasa (ten sam pakiet) | Podklasa (inny pakiet) | Ogół |
|------------|:-----:|:-------:|:-------------------:|:-------------------:|:-----:|
| **public** |   ✔   |    ✔    |         ✔           |         ✔           |   ✔   |
| **protected** |   ✔   |    ✔    |         ✔           |         ✔           |   ❌   |
| *no modifier* |   ✔   |    ✔    |         ✔           |         ❌           |   ❌   |
| **private** |   ✔   |    ❌    |         ❌           |         ❌           |   ❌   |

#### Typy danych

Wszystko w języku Java musi mieć określony typ, czy to będzie właściwość czy metoda, którą właśnie napisaliśmy.

Określony typ danych będzie pilnował aby metoda czy właściwość zwróciła wartość deklarowanego typu!

| Typ danych    | Opis                                      | Przykładowe użycie w kodzie                   |
|--------------|-----------------------------------------|-----------------------------------------------|
| **Prymitywne** | **Podstawowe typy danych w Javie**     |                                               |
| `byte`       | 8-bitowa liczba całkowita               | `byte smallNumber = 100;`                     |
| `short`      | 16-bitowa liczba całkowita              | `short pageCount = 32000;`                    |
| `int`        | 32-bitowa liczba całkowita              | `int age = 25;`                               |
| `long`       | 64-bitowa liczba całkowita              | `long distance = 1000000000L;`                |
| `float`      | 32-bitowa liczba zmiennoprzecinkowa      | `float price = 10.99f;`                       |
| `double`     | 64-bitowa liczba zmiennoprzecinkowa      | `double pi = 3.14159265358979;`               |
| `char`       | Pojedynczy znak Unicode                 | `char grade = 'A';`                           |
| `boolean`    | Wartość logiczna (`true`/`false`)       | `boolean isJavaFun = true;`                   |
| **Referencyjne** | **Obiekty i tablice**               |                                               |
| `String`     | Ciąg znaków                             | `String name = "John Doe";`                   |
| `Integer`    | Obiektowa wersja `int`                  | `Integer number = Integer.valueOf(42);`       |
| `Double`     | Obiektowa wersja `double`               | `Double temperature = 36.6;`                  |
| `Boolean`    | Obiektowa wersja `boolean`              | `Boolean isActive = Boolean.TRUE;`            |
| `List<T>`    | Lista dynamiczna                       | `List<String> names = new ArrayList<>();`     |
| `Set<T>`     | Zbiór unikalnych wartości              | `Set<Integer> uniqueNumbers = new HashSet<>();` |
| `Map<K, V>`  | Mapa klucz-wartość                     | `Map<String, Integer> scores = new HashMap<>();` |
| `Object`     | Klasa bazowa dla wszystkich obiektów   | `Object obj = new String("Hello");`           |
| `var`        | Typ inferowany                         | `var message = "Hello, Java!";`               |

#### Tworzenie klasy

Po krótkim i podstawowym wstępnie merytorycznym możemy przejść do utworzenia swojej pierwszej klasy, omawiając kolejne zaganienia w trakcie.

Nasza utworzona klasa powinna nadal wyglądać w ten sposób.
```java
public class Counter {

}
```
##### Konstruktor 
Aby tą klase można było `skonstruować` należy utworzyć jej konstruktor.
**Konstruktor jest to specjalna metoda klasy która jest wywoływana automatycznie przy tworzeniu nowego obiektu. Jego głównym zadaniem jest inicjalizacja (czyli nadanie wartości) właściwości obiektu.**
Konstruktor natomiast nie posiada żadnego typu ani zakresu widoczności, ale ma tą samą nazwę co klasa w której piszemy. Zapisuje się go wewnątrz klasy następująco.

```java
Counter(){
  
}
```

Jak już wcześniej się dowiedzieliśmy służy do inicjalizacji właściwości obiektu. Czyli przypisania wartości (w trakcie tworzenia obiektu tej klasy) do już istniejących zmiennych czekających na wartość wewnątrz tej klasy.

>[!NOTE]
> Konstruktorów klasa może mieć nieskończenie wiele, mogą również być puste co by oznaczało, że nową klasę tworzymy bez przypisania żadnych wartości i nie możemy nią "manipulować".
>
> Jeżeli klasa ma kilka konstruktorów to mówimy, że taka klasa ma `przeciążony konstruktor`. Oznacza to, że możemy stworzyć klasę na kilka różnych sposobów, np. podając różnego typu wartości.

<details>
  <summary> ℹ️ Przykład przeciążenia konstruktora </summary>

```java
class Car {
    String brand;
    String model;
    int year;

    // 🔹 Konstruktor 1: Domyślny (bez parametrów)
    Car() {
        this.brand = "Nieznana";
        this.model = "Nieznany";
        this.year = 0;
    }

    // 🔹 Konstruktor 2: Dwa parametry
    Car(String brand, String model) {
        this.brand = brand;
        this.model = model;
        this.year = 2024;  // Domyślny rok
    }

    // 🔹 Konstruktor 3: Trzy parametry
    Car(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    void showInfo() {
        System.out.println("Samochód: " + brand + " " + model + " (" + year + ")");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car1 = new Car();  // Używa pierwszego konstruktora
        Car car2 = new Car("Toyota", "Corolla");  // Używa drugiego konstruktora
        Car car3 = new Car("Ford", "Mustang", 1969);  // Używa trzeciego konstruktora

        car1.showInfo();  // Samochód: Nieznana Nieznany (0)
        car2.showInfo();  // Samochód: Toyota Corolla (2024)
        car3.showInfo();  // Samochód: Ford Mustang (1969)
    }
}
```
  
</details>

Więc utwórzmy jakąś właściwość dla naszej klasy `Counter` i konstruktor do zainicjalizowania jej.
Naszymi właściwościami będą:
- wartość
- krok
- czyAktywny
- nazwa (bo chcemy go sobie nazwać)

Nasz konstruktor powinien wyglądać następująco.

![obraz](https://github.com/user-attachments/assets/be5e9f3b-7e0e-4bf2-8c55-3169a38eab74)

Wewnątrz konstruktora stosujemy słówko kluczowe `this` odwołujące się do tej klasy, a po kropce możemy odwołać się do właściwości `TEJ` klasy. Dlatego też inicjalizacje czyli przypisanie możemy rozumieć w dosłowny sposób:
`ta właściwość ma mieć przypisaną tą wartość` które zostaną nadane przez programiste tworzącego klase.

##### Metody

Słowo `metoda` padło już kilkukrotnie, natomiast późno zostanie wyjaśnione z prostego założenia - że wy już wiecie.

**Metoda - zestaw instrukcji, który wykonuje określone zadanie za pośrednictwem konkretnego obiektu klasy. Można ją wywołać wiele razy, co pozwala uniknąć powtarzania tego samego kodu w różnych miejscach programu.**

Aby utworzyć metodę należy określić przede wszystkim jej typ, który musimy zwrócić na końcu jej działania.

W naszym przypadku będzie to metoda pokazująca nam wartość i powinna wyglądać następująco

![obraz](https://github.com/user-attachments/assets/dcca2937-e16e-4aba-bbaf-99715f1cc36b)

>[!WARNING]
>W przypadku typu `void` nie potrzebujemy zwracać nic z naszej funkcji.
>
>A `System.out.println` wypisuje tekst do konsoli. 

**🌠 Zadania do wykonania**
- [ ] Napisz nową metodę dla klasy Counter, która będzie zwiększała licznik o wartość kroku, tylko w przypadku jeżeli licznik jest aktywny.
- [ ] Napisz nowe metody dla klasy Counter, które zwrócą wartości właściwości klasy. Na każdą właściwość ma być jedna metoda.

##### Gettery/Settery

W ostatnim zadaniu mieliśmy utworzyć metody, które zwracają wartość poszczególnych właściwości - tym właśnie są `gettery`.

**Gettery i settery to metody dostępowe, które pozwalają odczytywać i zmieniać wartości prywatnych pól klasy. Dzięki nim możemy kontrolować, jak modyfikowane są właściwości obiektu.**

Przykładowy getter oraz setter dla właściwości powinien wyglądać następująco:

![obraz](https://github.com/user-attachments/assets/afcbfb53-2301-4bd2-ae6a-1fcc286ab3b3)

**🌠 Zadania do wykonania**
- [ ] Stwórz resztę getterów i setterów dla właściwości, pamiętaj, że przedrostek dla getterów to `get` a dla setterów to `set` w celu łatwego rozróżnienia funkcjonalności tych metod.
- [ ] Aby gettery i settery miały sens istnienia, pamiętaj aby zmienić `scope` właściwości na prywatny.

#### Tworzenie obiektu

Aby faktycznie przedstawić istnieje obiektu na podstawie klasy Counter, należy go utworzyć i wywołać.

Zrobimy to za pomocą przycisku w naszej aplikacji.
- W pliku `MainActivity.java` utwórz nową metodę klasy o nazwie `createCounter(View view)`.
- Następnie dodaj nowy przycisk do prostego widoku aplikacji i połącz metodę `createCounter` z właściwością `onClick` przycisku.

Wewnątrz metody `createCounter` utworzymy obiekt typu Counter w następujący sposób i wywołamy metodę obiektu `showValue`.

![obraz](https://github.com/user-attachments/assets/48867c82-7b52-42ff-bc11-8c69562da67a)

##### 🌠 Zadania do wykonania
- Utwórz nową klasę w oddzielnym pliku o nazwie `PizzaFactory`, celem tej klasy jest możliwość utworzenia obiektu `pizza`, który będzie mógł mieć określoną wielkość, nazwę, wartość określającą czy jest bezglutenowa, bazowy sos, stan surowości pizzy oraz pustą listę składników. Listę składników należy zaimplementować za pomocą metody.
- Każdy ze składników będzie dodany za pomocą odpowiedniego przycisku w aplikacji.
- Przyciskami dodatkowymi będzie można "podpiec pizzę" w skali 1/10, każde kliknięcie przycisku ma zwiększać licznik i tym samym zmieniać stan pizzy przy konkretnych prograch.
- Ostatnim przyciskiem będzie "wydanie pizzy" który wyświetli wszystkie informacje o zaserwowanej pizzy w ładny sposób na konsoli `Logcat`.

>[!NOTE]
> Klasa ma zawierać wszystkie metody, gettery, settery oraz 3 przeciążone konstruktury!
